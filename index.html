<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="The Hex Book, all in one place (Hexbound Edition).">
    <meta name="author" content="Cypher121">
    <link rel="icon" href="icon.png">

    <title>Hex Book</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css"
          integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.3.0/font/bootstrap-icons.css">
    <style>
        summary { display: list-item; }

        details.spell-collapsible {
            display: inline-block;
            border: 1px solid #aaa;
            border-radius: 4px;
            padding: .5em .5em 0;
            margin-bottom: .5em;
        }

        summary.collapse-spell {
            font-weight: bold;
            margin: -.5em -.5em 0;
            padding: .5em;
        }

        details.spell-collapsible[open] {
            padding: .5em;
        }

        details[open] summary.collapse-spell {
            border-bottom: 1px solid #aaa;
            margin-bottom: .5em;
        }

        details .collapse-spell::before {
            content: "Click to show spell";
        }
        details[open] .collapse-spell::before {
            content: "Click to hide spell";
        }
        blockquote.crafting-info {
            font-size: inherit;
        }
        a.permalink {
            margin-left: 0.5em;
        }
        a.permalink:hover {
            color: lightgray;
        }
        p {
            margin: 0.5ex 0;
        }
        p.fake-li {
            margin: 0;
        }
        p.fake-li::before {
            content: "\2022";
            margin: 1ex;
        }
        .linkout::before {
            content: "Link: ";
        }
        p.todo-note {
            font-style: italic;
            color: lightgray;
        }
        .obfuscated {
            filter: blur(1em);
        }
        .spoilered {
            filter: blur(1ex);
            -moz-transition: filter 0.04s linear;
        }
        .spoilered:hover {
            filter: blur(0.5ex);
        }
        .spoilered.unspoilered {
            filter: blur(0);
        }
        canvas.spell-viz {
            --dot-color: #777f;
            --dot-color: #777f;
            --start-dot-color: #f009;
            --moving-dot-color: #0fa9;

            --path-color: darkgray;
            --visited-path-color: #0c8;

            --dot-scale: 0.0625;
            --moving-dot-scale: 0.125;
            --line-scale: 0.08333;
            --pausetext-scale: 0.5;
            --dark-mode: 0;
        }

        @media (prefers-color-scheme: dark) {
            body {
                background-color: #201a20;
                color: #ddd;
            }

            .jumbotron {
                background-color: #323;
            }

            canvas.spell-viz {
                /* hack */
                --dark-mode: 1;
            }
        }

    </style>
    <noscript>
        <style>
            /* for accessibility */
            .spoilered {
                filter: none !important;
            }

        </style>
    </noscript>
    <script>
        "use strict";
        const speeds = [0, 0.25, 0.5, 1, 2, 4];
        const scrollThreshold = 100;
        const rfaQueue = [];
        const colorCache = new Map();
        function getColorRGB(ctx, str) {
            if (!colorCache.has(str)) {
                ctx.fillStyle = str;
                ctx.clearRect(0, 0, 1, 1);
                ctx.fillRect(0, 0, 1, 1);
                const imgData = ctx.getImageData(0, 0, 1, 1);
                colorCache.set(str, imgData.data);
            }
            return colorCache.get(str);
        }
        function startAngle(str) {
            switch (str) {
                case "east": return 0;
                case "north_east": return 1;
                case "north_west": return 2;
                case "west": return 3;
                case "south_west": return 4;
                case "south_east": return 5;
                default: return 0;
            }
        }
        function offsetAngle(str) {
            switch (str) {
                case "w": return 0;
                case "q": return 1;
                case "a": return 2;
                case "s": return 3;
                case "d": return 4;
                case "e": return 5;
                default: return -1;
            }
        }
        function initializeElem(canvas) {
            const str = canvas.dataset.string;
            let angle = startAngle(canvas.dataset.start);
            const perWorld = canvas.dataset.perWorld === "True";

            // build geometry
            const points = [[0, 0]];
            let lastPoint = points[0];
            let minPoint = lastPoint, maxPoint = lastPoint;
            for (const ch of "w" + str) {
                const addAngle = offsetAngle(ch);
                if (addAngle < 0) continue;
                angle = (angle + addAngle) % 6;
                const trueAngle = Math.PI / 3 * angle;

                const [lx, ly] = lastPoint;
                const newPoint = [lx + Math.cos(trueAngle), ly - Math.sin(trueAngle)];

                points.push(newPoint);
                lastPoint = newPoint;

                const [mix, miy] = minPoint;
                minPoint = [Math.min(mix, newPoint[0]), Math.min(miy, newPoint[1])];
                const [max, may] = maxPoint;
                maxPoint = [Math.max(max, newPoint[0]), Math.max(may, newPoint[1])];
            }
            const size = Math.min(canvas.width, canvas.height) * 0.8;
            const scale = size / Math.max(3, Math.max(maxPoint[1] - minPoint[1], maxPoint[0] - minPoint[0]));
            const center = [(minPoint[0] + maxPoint[0]) * 0.5, (minPoint[1] + maxPoint[1]) * 0.5];
            const truePoints = points.map(p => [canvas.width * 0.5 + scale * (p[0] - center[0]), canvas.height * 0.5 + scale * (p[1] - center[1])]);
            let uniqPoints = [];
            l1: for (const point of truePoints) {
                for (const pt of uniqPoints) {
                    if (Math.abs(point[0] - pt[0]) < 0.00001 && Math.abs(point[1] - pt[1]) < 0.00001) {
                        continue l1;
                    }
                }
                uniqPoints.push(point);
            }

            // rendering code
            const speed = 0.0025;
            const context = canvas.getContext("2d");
            const negaProgress = -3;
            let progress = 0;
            let scrollTimeout = 1e309;
            let speedLevel = 3;
            let speedIncrement = 0;
            function speedScale() {
                return speeds[speedLevel];
            }

            const style = getComputedStyle(canvas);
            const getProp = n => style.getPropertyValue(n);

            const tick = dt => {
                scrollTimeout += dt;
                if (canvas.offsetParent === null) return;

                const strokeStyle = getProp("--path-color");
                const strokeVisitedStyle = getProp("--visited-path-color");

                const startDotStyle = getProp("--start-dot-color");
                const dotStyle = getProp("--dot-color");
                const movDotStyle = getProp("--moving-dot-color");

                const strokeWidth = scale * +getProp("--line-scale");
                const dotRadius = scale * +getProp("--dot-scale");
                const movDotRadius = scale * +getProp("--moving-dot-scale");
                const pauseScale = scale * +getProp("--pausetext-scale");
                const bodyBg = scale * +getProp("--pausetext-scale");
                const darkMode = +getProp("--dark-mode");
                const bgColors = getColorRGB(context, getComputedStyle(document.body).backgroundColor);


                if (!perWorld) {
                    progress += speed * dt * (progress > 0 ? speedScale() : Math.sqrt(speedScale()));
                }
                if (progress >= truePoints.length - 1) {
                    progress = negaProgress;
                }
                let ix = Math.floor(progress), frac = progress - ix, core = null, fadeColor = 0;
                if (ix < 0) {
                    const rawFade = 2 * progress / negaProgress - 1;
                    fadeColor = 1 - Math.abs(rawFade);
                    context.strokeStyle = rawFade > 0 ? strokeVisitedStyle : strokeStyle;
                    ix = rawFade > 0 ? truePoints.length - 2 : 0;
                    frac = +(rawFade > 0);
                } else {
                    context.strokeStyle = strokeVisitedStyle;
                }

                const [lx, ly] = truePoints[ix];
                const [rx, ry] = truePoints[ix + 1];
                core = [lx + (rx - lx) * frac, ly + (ry - ly) * frac];


                context.clearRect(0, 0, canvas.width, canvas.height);
                context.beginPath();
                context.lineWidth = strokeWidth;
                context.moveTo(truePoints[0][0], truePoints[0][1]);
                for (let i = 1; i < ix + 1; i++) {
                    context.lineTo(truePoints[i][0], truePoints[i][1]);
                }
                context.lineTo(core[0], core[1]);
                context.stroke();
                context.beginPath();
                context.strokeStyle = strokeStyle;
                context.moveTo(core[0], core[1]);
                for (let i = ix + 1; i < truePoints.length; i++) {
                    context.lineTo(truePoints[i][0], truePoints[i][1]);
                }
                context.stroke();

                for (let i = 0; i < uniqPoints.length; i++) {
                    context.beginPath();
                    context.fillStyle = (i == 0 && !perWorld) ? startDotStyle : dotStyle;
                    const radius = (i == 0 && !perWorld) ? movDotRadius : dotRadius;
                    context.arc(uniqPoints[i][0], uniqPoints[i][1], radius, 0, 2 * Math.PI);
                    context.fill();
                }

                if (!perWorld) {
                    context.beginPath();
                    context.fillStyle = movDotStyle;
                    context.arc(core[0], core[1], movDotRadius, 0, 2 * Math.PI);
                    context.fill();
                }
                if (fadeColor) {
                    context.fillStyle = `rgba(${bgColors[0]}, ${bgColors[1]}, ${bgColors[2]}, ${fadeColor})`;
                    context.fillRect(0, 0, canvas.width, canvas.height);
                }
                if (scrollTimeout <= 2000) {
                    context.fillStyle = `rgba(200, 200, 200, ${(2000 - scrollTimeout) / 1000})`;
                    context.font = `${pauseScale}px sans-serif`;
                    context.fillText(speedScale() ? speedScale() + "x" : "Paused", 0.2 * scale, canvas.height - 0.2 * scale);
                }
            };
            rfaQueue.push(tick);

            // scrolling input
            if (!perWorld) {
                canvas.addEventListener("wheel", ev => {
                    speedIncrement += ev.deltaY;
                    const oldSpeedLevel = speedLevel;
                    if (speedIncrement >= scrollThreshold) {
                        speedLevel--;
                    } else if (speedIncrement <= -scrollThreshold) {
                        speedLevel++;
                    }
                    if (oldSpeedLevel != speedLevel) {
                        speedIncrement = 0;
                        speedLevel = Math.max(0, Math.min(speeds.length - 1, speedLevel));
                        scrollTimeout = 0;
                    }
                    ev.preventDefault();
                });
            }
        }
        function hookLoad(elem) {
            let init = false;
            const canvases = elem.querySelectorAll("canvas");
            elem.addEventListener("toggle", () => {
                if (!init) {
                    canvases.forEach(initializeElem);
                    init = true;
                }
            });
        }
        function hookToggle(elem) {
            const details = Array.from(document.querySelectorAll("details." + elem.dataset.target));
            elem.addEventListener("click", () => {
                if (details.some(x => x.open)) {
                    details.forEach(x => x.open = false);
                } else {
                    details.forEach(x => x.open = true);
                }
            });
        }
        const params = new URLSearchParams(document.location.search);
        function hookSpoiler(elem) {
            if (params.get("nospoiler") !== null) {
                elem.classList.add("unspoilered");
            } else {
                const thunk = ev => {
                    if (!elem.classList.contains("unspoilered")) {
                        ev.preventDefault();
                        ev.stopImmediatePropagation();
                        elem.classList.add("unspoilered");
                    }
                    elem.removeEventListener("click", thunk);
                };
                elem.addEventListener("click", thunk);

                if (elem instanceof HTMLAnchorElement) {
                    const href = elem.getAttribute("href");
                    if (href.startsWith("#")) {
                        elem.addEventListener("click", () => document.getElementById(href.substring(1)).querySelector(".spoilered").classList.add("unspoilered"));
                    }
                }
            }
        }
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('details.spell-collapsible').forEach(hookLoad);
            document.querySelectorAll('a.toggle-link').forEach(hookToggle);
            document.querySelectorAll('.spoilered').forEach(hookSpoiler);
            function tick(prevTime, time) {
                const dt = time - prevTime;
                for (const q of rfaQueue) {
                    q(dt);
                }
                requestAnimationFrame(t => tick(time, t));
            }
            requestAnimationFrame(t => tick(t, t));
        });

    </script>

</head>
<body>
<div class="container" style="margin-top: 3em;">
    <blockquote>
        <h1>This is the online version of the Hexbound documentation.</h1>
        <p>Embedded images and patterns are included, but not crafting recipes or items. There's an in-game book for
            those.</p>
        <p>Additionally, this is built from the latest code on GitHub. It may describe <b>newer</b> features that you
            may not necessarily have, even on the latest CurseForge version!</p>
        <p><b>Entries which are blurred are spoilers</b>. Click to reveal them, but be aware that they may spoil endgame
            progression. Alternatively, click <a href="?nospoiler">here</a> to get a version with all spoilers showing.
        </p>
    </blockquote>
</div>
<div class='container'><header class='jumbotron'><h1 class='book-title'>Hex Notebook</h1><p>I seem to have discovered a new method of magical arts, in which one draws patterns strange and wild onto a hexagonal grid. It fascinates me. I've decided to start a journal of my thoughts and findings.</p><p><a href='https://forum.petra-k.at/index.php'>Forum Link</a></p></header><nav><h2 id='table-of-contents' class='page-header'>Table of Contents<a href='javascript:void(0)' class='toggle-link small' data-target='toc-category'>(toggle all)</a><a href='#table-of-contents' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><details class='toc-category'><summary><a href='#patterns' class=''>Patterns</a></summary><ul><li><a href='#patterns/hexkinetics_mathematics' class=''>HexKinetics Mathematics</a></li><li><a href='#patterns/hexkinetics_patterns' class=''>HexKinetics Patterns</a></li></ul></details><details class='toc-category'><summary><a href='#patterns/spells' class=''>Spells</a></summary><ul><li><a href='#patterns/spells/hexkinetics_spells' class=''>HexKinetics Spells</a></li></ul></details><details class='toc-category'><summary><a href='#patterns/great_spells' class=''>Great Spells</a></summary><ul><li><a href='#patterns/great_spells/greatertranslocation' class=''>Greater Translocation</a></li><li><a href='#patterns/great_spells/great_kinetics' class=''>Kinetics</a></li></ul></details></nav><main class='book-body'><section id='patterns'><h2 class='category-title page-header'>Patterns<a href='#patterns' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><p>A list of all the patterns I've discovered, as well as what they do.</p><div id='patterns/hexkinetics_mathematics'><h3 class='entry-title page-header'>HexKinetics Mathematics<a href='#patterns/hexkinetics_mathematics' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><div id='patterns/hexkinetics_mathematics@hexkinetics:argument/const'><h4 class='pattern-title'>Argument Distillation (vector, number → number)<a href='#patterns/hexkinetics_mathematics@hexkinetics:argument/const' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='eeeeeq' data-start='south_west' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: eeeeeq</canvas></details><p>Takes vector and number off the stack, then pushes the number in vector indexed by the given number to the top of the stack. If given larger number then 3 or smaller than 1 returns Null.</p></div><br /><div id='patterns/hexkinetics_mathematics@hexkinetics:reflection/const'><h4 class='pattern-title'>Optician's Distillation (vector, vector → vector)<a href='#patterns/hexkinetics_mathematics@hexkinetics:reflection/const' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='qqqqqdqqqqq' data-start='south_east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: qqqqqdqqqqq</canvas></details><p>This operation retrieves two vectors from the stack and calculates a vector reflection of the first vector based on the second vector, which acts as a normal and defines the reflection plane.</p></div><br /><div id='patterns/hexkinetics_mathematics@hexkinetics:hadamard/const'><h4 class='pattern-title'>Hadamard's Distillation (vector, vector → vector)<a href='#patterns/hexkinetics_mathematics@hexkinetics:hadamard/distillation' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='awaqawa' data-start='west' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: awaqawa</canvas></details><p>Elements corresponding to the same columns of given vectors are multiplied together to form a new vector.</p></div><br /><div id='patterns/hexkinetics_mathematics@hexkinetics:round/const'><h4 class='pattern-title'>Imprecision Purification (vec/num → vec/num)<a href='#patterns/hexkinetics_mathematics@hexkinetics:round/const' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='aadeeaa' data-start='south_east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: aadeeaa</canvas></details><p>Number or elements in given vector are rounded to the nearest whole.</p></div><br /></div><div id='patterns/hexkinetics_patterns'><h3 class='entry-title page-header'>HexKinetics Patterns<a href='#patterns/hexkinetics_patterns' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><div id='patterns/hexkinetics_patterns@hexkinetics:direction/const'><h4 class='pattern-title'>Alidade's Purification II (entity → vector) <a href='#patterns/hexkinetics_patterns@hexkinetics:direction/const' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='waa' data-start='east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: waa</canvas></details><p>Alidade's Purification but it returns the direction player is looking in form of full, round vectors, as (0,1,0).</p></div><br /><div id='patterns/hexkinetics_patterns@hexkinetics:pixel/raycast'><h4 class='pattern-title'>Sniper's Distillation (vector, vector → vector) <a href='#patterns/hexkinetics_patterns@hexkinetics:pixel/raycast' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='weqaqded' data-start='east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: weqaqded</canvas></details><p>Architect's Distillation but it  returns the precise hit position. Very versatile, it can be used on various entities and materials with the exception of air.</p></div><br /><div id='patterns/hexkinetics_patterns@hexkinetics:is_gravity/const'><h4 class='pattern-title'>Inertia Purification (entity → bool)<a href='#patterns/hexkinetics_patterns@hexkinetics:is_gravity/const' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='daad' data-start='east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: daad</canvas></details><p>Determines whether the entity is currently in a state of inertia or if it is subject to the force of gravity. If the entity is found to be in a state of inertia, purification returns true.</p></div><br /></div></section><section id='patterns/spells'><h2 class='category-title page-header'>Spells<a href='#patterns/spells' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><p>Patterns and actions that perform a magical effect on the world.</p><div id='patterns/spells/naseua'><h3 class='entry-title page-header'>Nadir of Nausea<a href='#patterns/spells/naseua' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><div id='patterns/spells/naseua@hextweaks:nausea'><h4 class='pattern-title'>Nadir of Nausea (entity, number, number →)<a href='#patterns/spells/naseua@hextweaks:nausea' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='weed' data-start='east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: weed</canvas></details><p>Inflicts <span style='color: #8d6acc'>nausea</span>. Base cost is one Amethyst Dust per 4 seconds.</p></div><br /></div></section><section id='patterns/great_spells'><h2 class='category-title page-header'>Great Spells<a href='#patterns/great_spells' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><p>The spells catalogued here are purported to be of legendary difficulty and power. They seem to have been recorded only sparsely (for good reason, the texts claim). It's probably just the hogwash of extinct traditionalists, though-- a pattern's a pattern. What could possibly go wrong?</p><div id='patterns/great_spells/greatertranslocation'><h3 class='entry-title page-header'>Greater Translocation<a href='#patterns/great_spells/greatertranslocation' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><div id='patterns/great_spells/greatertranslocation@hexkinetics:greater_translocation/spell'><h4 class='pattern-title'>Greater Translocation (vec, vec →)<a href='#patterns/great_spells/greatertranslocation@hexkinetics:greater_translocation/spell' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='eeqeeqeeeqeeqdeeqeqqwqqqeeqeqqwqq' data-start='south_east' data-per-world=True>Your browser does not support visualizing patterns. Pattern code: eeqeeqeeeqeeqdeeqeqqwqqqeeqeqqwqq</canvas></details><p>Works like Greater Teleport but allows me to move blocks instead of entities. It works on all blocks.</p></div><br /></div><div id='patterns/great_spells/great_kinetics'><h3 class='entry-title page-header'>Kinetics<a href='#patterns/great_spells/great_kinetics' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><div id='patterns/great_spells/great_kinetics@hexkinetics:greater_impulse/spell'><h4 class='pattern-title'>Greater Impulse<a href='#patterns/great_spells/great_kinetics@hexkinetics:greater_impulse' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='wqeqaaeeeweeeaaqeqqaaq' data-start='south_west' data-per-world=True>Your browser does not support visualizing patterns. Pattern code: wqeqaaeeeweeeaaqeqqaaq</canvas></details><p>It appears to be a pattern, I wonder what happens if I cast it</p></div><br /></div></section></main></div>
</body>
</html>
